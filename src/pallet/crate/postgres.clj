(ns pallet.crate.postgres
  "Install and configure PostgreSQL.

# Settings

Settings are constructed with the settings-map function.

The settings map has a :permissions, :options, and :recovery keys
used to specify the default database hba.conf, postgresal.conf and
recovery.conf files. Paths in the default options should contain a
\"%s\" for the database cluster name (n.b. a cluster is a group
of databases running under the same postmaster process).

The settings-map should be passed to the `settings` crate function
which fills out the target specific paths, etc. Paths passed to `settings`
should contain a \"%s\" to receive the database name.

For each database cluster, `database-settings` must be called to set up the
database specific settings from the default settings passed to the `settings`
function.  Database specific settings may be set up by passing a settings map
to the `database-settings` function. Paths passed to database-settings should
be complete amd not contain \"%s\" placeholders.

## Settings map details

These keys can also appear under the :dbs key for database cluster specific
settings, in which case the paths should be plain strings.

For example:

    {:options {:port 5432
               :data_directory \"/var/lib/pgsql/%s\"}
     :clusters {:db1
            {:options {:port :5433
                       :data_directory \"/var/lib/pgsql/db1\"}}}}

Links:
-  http://blog.2ndquadrant.com/en/2010/05/install-multiple-postgresql-servers-redhat-linux.html
  "
  (:require
   [pallet.action :as action]
   [pallet.actions :refer [add-rpm content-options directory exec-checked-script
                           exec-script file package package-manager
                           package-source remote-file]
    :as actions]
   [pallet.api :refer [plan-fn] :as api]
   [pallet.compute :as compute]
   [pallet.core.session :refer [session]]
   [pallet.crate :refer [assoc-settings defplan get-settings os-family
                         target-node update-settings]]
   [pallet.crate-install :as crate-install]
   [pallet.crate.etc-default :as etc-default]
   [pallet.crate.postgres.config :as config]
   [pallet.crate.postgres.kb :as kb]
   [pallet.crate.service
    :refer [supervisor-config supervisor-config-map] :as service]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.node :refer [is-64bit?]]
   [pallet.utils :refer [apply-map]]
   [clojure.tools.logging :as logging]
   [clojure.string :as string])
  (:use
   [pallet.crate.package.debian-backports :only [add-debian-backports]]
   [pallet.script :only [defscript]]
   [pallet.version-dispatch
    :only [defmethod-version defmulti-version defmulti-version-plan
           defmethod-version-plan defmulti-version-plan os-map os-map-lookup]
    :as version-dispatch]
   [pallet.versions :only [as-version-vector version-string]]))


(def facility
  "The settings facility for postgres."
  ::postgresql)

(def ^{:private true} pallet-cfg-preamble
"# This file was auto-generated by Pallet. Do not edit it manually unless you
# know what you are doing. If you are still using Pallet, you probably want to
# edit your Pallet scripts and rerun them.\n\n")

(def ^{:doc "Flag for recognising changes to configuration"}
  postgresql-config-changed-flag "postgresql-config")

;;; Install strategy
(defn postgres-rpm-settings
  "Returns a settings map for install via the Postgres RPM repository."
  [version components os-family os-version arch]
  (let [arch (if (is-64bit? (target-node)) "x86_64" "i386")]
    {:install-strategy :rpm-repo
     :rpm {:name "pgdg.rpm"
           :url (kb/pgdg-url
                 (version-string version) os-family os-version arch)}
     :packages (kb/pgdg-packages
                (version-string version)
                components)
     :layout :pgdg}))

(defn postgres-apt-settings
  [version]
  {:install-strategy :package-source
   :package-source
   {:name "Postgres Apt"
    :aptitude kb/postgres-apt
    :apt kb/postgres-apt}
   :packages (kb/postgres-apt-packages (version-string version))
   :layout :debian-base})

(defn packages-settings
  [version components]
  {:install-strategy :packages
   :packages (kb/package-names
              (os-family)
              (version-string version)
              components)})

(defmulti-version-plan install-strategy
  ;; Default install strategy, if none supplied.
  [version settings])

(defmethod-version-plan install-strategy {:os :rh-base}
  [os os-version version settings]
  (packages-settings version nil))

(defmethod-version-plan install-strategy {:os :debian-base}
  [os os-version version settings]
  (packages-settings version nil))

;;; Default settings
(def default-settings-map
  {:components #{:server :contrib}
   :owner "postgres"
   :options {:port 5432
             :max_connections 100
             :ssl false
             :shared_buffers "24MB"
             :log_line_prefix "%t "
             :datestyle "iso, ymd"
             :default_text_search_config "pg_catalog.english"
             :logging_collector "on"}
   :permissions [["local" "all" "postgres" "ident" ""]
                 ["local" "postgres" "postgres" "ident" ""]]
   :start {:start :auto}
   :listen_addresses "127.0.0.1"})

(def allow-ident-permissions
  [["host" "all" "all" "127.0.0.1/32" "ident"]
   ["host" "all" "all" "::1/128" "ident"]])

(defn merge-settings
  "Merge postgresql settings maps"
  [& settings]
  (reduce
   (fn [defaults overrides]
     (merge
      defaults
      overrides
      (into {} (map
                #(vector % (merge (% defaults) (% overrides)))
                [:options :recovery :start]))
      (into {}
            (map
             #(vector % (distinct (concat (% defaults) (% overrides))))
             [:permissions]))))
   settings))

;;; database cluster variants

(defn hot-standby-master
  "Set up hot standby master defaults"
  [settings]
  (merge-settings
   {:options
    {:wal_level "hot_standby"
     :max_wal_senders 5
     :wal_keep_segments 32
     :archive_mode "on"
     :archive_command (str "cp %p " (-> settings :wal_directory) "/%f")}}
   settings))

(defn hot-standby-replica
  "Set up hot standby replica defaults"
  [settings]
  (merge-settings
   {:options {:hot_standby "on"}
    :recovery
    {:standby_mode "on"
     :trigger_file (str (-> settings :options :data_directory) "/pg-failover")
     :restore_command (str "cp " (-> settings :wal_directory) "/%f \"%p\"")}}
   settings))

;;; Cluster specific settings

(defn cluster-settings-with-defaults
  "Combines a cluster specific settings map with the default settings"
  [cluster settings-map defaults]
  (let [expand-entry (fn [v]
                       (if (and (string? v) (re-find #".*%s" v))
                         (format v cluster)
                         v))
        expand (fn [m] (zipmap (keys m) (map expand-entry (vals m))))
        defaults (dissoc defaults :clusters) ; avoid nesting :clusters keys
        settings (merge-settings
                  (into {} (expand
                            (dissoc defaults :options :recovery :permissions)))
                  {:permissions (:permissions defaults)}
                  (into {} (map
                            #(vector % (expand (% defaults)))
                            [:options :recovery :start]))
                  settings-map)]
    (->
     settings
     ;; some paths that are always dependent on others
     (assoc :recovery_file (str
                            (-> settings :options :data_directory)
                            "/recovery.conf")
            :start_file (string/replace
                         (:postgresql_file settings)
                         #"postgresql.conf"
                         "start.conf"))
     ;; some specific differences
     (update-in [:service]
                #(if (and (= cluster (:default-cluster-name defaults))
                          (:default-service defaults))
                   (:default-service defaults)
                   %))
     (update-in [:options :external_pid_file]
                #(if (:use-port-in-pidfile defaults)
                   (format
                    (-> defaults :options :external_pid_file)
                    (-> settings :options :port))
                   %)))))

(defn settings-for-cluster
  "Returns the settings for the specified cluster"
  [cluster {:keys [instance-id] :as options}]
  (get-in
   (get-settings facility options)
   [:clusters (keyword cluster)]))

(defn check-settings
  "Check that settings are valid"
  [settings cluster-settings cluster & keys]
  (let [error-fn (fn [^String message]
                   (logging/error (format message cluster settings))
                   (assert false))
        missing-keys (remove #(get-in cluster-settings %) keys)]
    (when (not settings)
      (error-fn "No settings found %s %s"))
    (when (not cluster-settings)
      (error-fn "No cluster settings found %s %s"))
    (when (seq missing-keys)
      (error-fn (format "Missing keys %s %%s %%s" (vec missing-keys))))))

(defn conf-file
  "Generates a postgresql configuration file"
  [file-keys values-kw formatter {:keys [instance-id cluster] :as options}]
  (let [settings (get-settings facility options)
        cluster (or cluster (:default-cluster-name settings))
        cluster-settings (settings-for-cluster cluster options)
        conf-path (get-in cluster-settings file-keys)
        hba-contents (str pallet-cfg-preamble
                          (formatter (values-kw cluster-settings)))]
    (check-settings settings cluster-settings cluster file-keys)
    (directory
     (stevedore/script @(~lib/dirname ~conf-path))
     :owner (:owner settings "postgres") :mode "0700" :path true)
    (remote-file
     conf-path
     :content hba-contents
     :literal true
     :flag-on-changed postgresql-config-changed-flag
     :owner (:owner settings))
    (when-let [t (:selunix-file-t settings)]
      (exec-checked-script
       (str "SELinux chcon " conf-path " type " t)
       (lib/selinux-file-type ~conf-path ~t)))))

(defn default-cluster-name
  "Returns the default cluster name"
  [& {:keys [instance-id] :as options}]
  (let [settings (get-settings facility options)]
    (:default-cluster-name settings)))

;;; # Crate functions

(defn settings-map
  "Build a settings map for postgresql.
      :version     postgresql version to install, eg \"9.0\"
      :components  postgresql components to install
      :permissions permissions to set in pg_hba.conf A sequence of records
                   (either vectors or maps of keywords/strings).
      :options     options to set in postgresql.conf
      :recovery    options to set in recovery.conf

   Unrecognised options will be added to the main configuration file.

   Example: (settings-map
              {:options {:listen_address [\"10.0.1.1\",\"localhost\"]}})"
  [{:keys [version components permissions options recovery]
    :as args}]
  (merge-settings default-settings-map args))

(defn cluster-settings
  "Add cluster specific postgresql settings map to the session map.
   This crate function must be called (usually in the :settings phase)
   for each database cluster you want to manage. Must be called after
   `settings`.

   Options:
   - instance-id     Specify the postgres instance to use for the cluster
   - variant      Specify a variant for the cluster. Current options are
                  :hot-standby-master and :hot-standby-replica

   For variant :hot-standby-replica, you will need to pass :primary_conninfo
   in the `settings-map`"
  [cluster-name settings-map & {:keys [instance-id variant] :as options}]
  (let [settings (get-settings facility options)
        settings (cluster-settings-with-defaults
                   cluster-name settings-map settings)
        settings (case variant
                   :hot-standby-master (hot-standby-master settings)
                   :hot-standby-replica (hot-standby-replica settings)
                   settings)]
    (logging/debugf "Postgresql cluster %s settings %s" cluster-name settings)
    (update-settings
     facility instance-id
     assoc-in [:clusters (keyword cluster-name)]
     settings)))

;; (defn base-distribution
;;   "Base distribution of the target-node."
;;   []
;;   (compute/base-distribution (target-node)))

(defn settings
  "Add postgresql settings to the session map."
  [{:keys [instance-id version]
    :or {version (version-string (os-map-lookup @kb/postgres-package-version))}
    :as settings}]
  (let [options (select-keys settings [:instance-id])
        settings (-> settings
                     (assoc :version version)
                     (dissoc :instance-id))
        settings (if (:install-strategy settings)
                   settings
                   (merge (install-strategy version settings) settings))
        settings (merge-settings
                  (kb/layout-settings
                   (os-family) (:layout settings (os-family)) version)
                  settings)
        old-settings (get-settings facility options)]
    (logging/debugf "Postgresql Settings %s" settings)
    (assoc-settings
     facility (assoc settings :clusters (:clusters old-settings))
     options)
    (when-let [cluster-name (:default-cluster-name settings)]
      (cluster-settings cluster-name {} :instance-id instance-id))))


;;; ## Install
(defn install
  "Install postgres."
  [{:keys [instance-id] :as options}]
  (logging/debugf "install postgresql")
  (crate-install/install facility instance-id))

;;; ## Configure

(defn hba-conf
  "Generates a pg_hba.conf file from the arguments. Each record is either a
   vector or map of keywords/args.

   Note that pg_hba.conf is case-sensitive: all means all databases, ALL is a
   database named ALL.

   Also note that if you intend to execute subsequent commands, you'd do best to
   include entries in here that allow the admin user you are using easy access
   to the database. For example, allow the postgres user to have ident access
   over local.

   Options:
   :cluster        The database cluster to use
   :instance-id  The postgres instance to use"
  [{:keys [instance-id cluster] :as options}]
  (conf-file [:options :hba_file] :permissions config/hba options))

(defn postgresql-conf
  "Generates a postgresql.conf file from the arguments.

   Options:
   :cluster        The database cluster to use
   :instance-id  The postgres instance to use"
  [{:keys [instance-id cluster] :as options}]
  (conf-file [:postgresql_file] :options config/conf options))

(defn recovery-conf
  "Generates a recovery.conf file from the arguments.

   Options:
   :cluster        The database cluster to use
   :instance-id  The postgres instance to use"
  [{:keys [instance-id cluster] :as options}]
  (conf-file [:recovery_file] :recovery config/conf options))

(defn start-conf
  "Generates a start.conf file from the arguments. This is debian specific. See
   `service-config`, which works across distributions.

   Options:
   :cluster        The database cluster to use
   :instance-id  The postgres instance to use"
  [{:keys [instance-id cluster] :as options}]
  (conf-file [:start_file] :start config/start options))

(defn install-service
  "Generates a start.conf file from the arguments. This is specific to
   non-debian distributions. See `service-config`, which works across
   distributions.

   Options:
   :cluster        The database cluster to use
   :instance-id  The postgres instance to use"
  [{:keys [instance-id cluster] :as options}]
  (let [settings (get-settings facility options)]
    (doseq [cluster (keys (:clusters settings))]
      (let [cluster-name (name cluster)
            cluster-settings (settings-for-cluster cluster-name options)]
        (when (not= cluster-name (:default-cluster-name settings))
          ;; TODO
          ;; (service/init-script
          ;;  (:service cluster-settings)
          ;;  :remote-file (service/init-script-path (:default-service settings)))
          (etc-default/write
           (str "pgsql/" (:service cluster-settings))
           :PGDATA (-> cluster-settings :options :data_directory)
           :PGPORT (-> cluster-settings :options :port))
          ;; TODO
          ;; (if (= :auto (-> cluster-settings :start :start))
          ;;   (service/service (:service cluster-settings) :action :enable)
          ;;   (service/service (:service cluster-settings) :action :disable))
          )))))

(defn service-config
  "Configure the service architecture."
  [{:keys [instance-id cluster] :as options}]
  (let [settings (get-settings facility options)]
    (if (:has-multicluster-service settings)
      (start-conf options)
      (install-service options))))

(defn- port-config* [settings]
  (when-let [t (:selunix-port-t settings)]
    (let [p (-> settings :options :port)]
      (exec-checked-script
       (str "SELinux manage port " p " type " t)
       (if (&& (lib/has-command? semanage)
               (&& (directory? "/etc/selinux")
                   (file-exists? "/selinux/enforce")))
         (if (pipe ("semanage" port -l) ("fgrep" ~p))
           ("semanage" port -m -t ~t -p tcp ~p)
           ("semanage" port -a -t ~t -p tcp ~p)))))))

(defn port-config
  "Manage the SELinux port type of the configured port"
  [{:keys [instance-id cluster] :as options}]
  (let [settings (get-settings facility options)]
    (if (:has-multicluster-service settings)
      (doseq [cluster (keys (:clusters settings))
              :let [cluster-name (name cluster)
                    cluster-settings (settings-for-cluster
                                      cluster-name options)]]
        (port-config* cluster-settings))
      (port-config* settings))))

(defn dir-config*
  [{:keys [owner selunix-file-t options] :as settings}]
  (let [d (:unix_socket_directory options)]
    (directory d :owner owner)
    (when selunix-file-t
      (exec-checked-script
       (str "SELinux chcon " d " type " selunix-file-t)
       (lib/selinux-file-type ~d ~selunix-file-t)))))

(defn dir-config
  "Ensure required directories exist"
  [{:keys [instance-id cluster] :as options}]
  (let [settings (get-settings facility options)]
    (if (:has-multicluster-service settings)
      (doseq [cluster (keys (:clusters settings))
              :let [cluster-name (name cluster)
                    cluster-settings (settings-for-cluster
                                      cluster-name options)]]
        (dir-config* settings))
      (dir-config* settings))))

(defn initdb
  "Initialise a cluster"
  [{:keys [instance-id cluster] :as options}]
  (let [settings (get-settings facility options)
        cluster (or cluster (:default-cluster-name settings))
        initdb-via (:initdb-via settings :initdb)
        cluster-settings (settings-for-cluster cluster options)
        data-dir (-> cluster-settings :options :data_directory)]
    (case initdb-via
      :service (actions/service :action :initdb)
      :initdb  (do
                 (directory
                  data-dir
                  :owner (:owner settings "postgres")
                  :mode "0700"
                  :path true)
                 (exec-checked-script
                  "initdb"
                  (if (not (file-exists? ~(str data-dir "/PG_VERSION")))
                    ("sudo"
                     -u ~(:owner settings "postgres")
                     (lib/file ~(:bin settings) initdb)
                     -D ~data-dir)))))))

;;; Scripts

(defn postgresql-script
  "Execute a postgresql script.

   The script is specified using remote-file content options (:content for
   a literal script)

   Options for how this script should be run:
     :as-user username       - Run this script having sudoed to this (system)
                               user. Default: postgres
     :db-name database       - the name of the database to connect to
     :cluster cluster-name   - the name of the cluster to connect to
     :instance-id instance-name - the instance (pg install) to use
     :ignore-result          - Ignore any error return value out of psql
     :title string           - A title to be used in script output."
  [& {:keys [as-user instance-id cluster db-name ignore-result show-stdout
             title]
      :or {show-stdout true}
      :as options}]
  (let [settings (get-settings facility options)
        cluster (or cluster (:default-cluster-name settings))
        cluster-settings (settings-for-cluster cluster options)
        as-user (or as-user (-> settings :owner))
        file (str (stevedore/script @TMPDIR:-/tmp) "/"
                  (gensym "postgresql") ".sql")]

    (apply-map remote-file file
               :no-versioning true
               :owner as-user
               (select-keys options content-options))
    (exec-checked-script
     ;; Note that we stuff all output. This is because certain commands in
     ;; PostgreSQL are idempotent but spit out an error and an error exit
     ;; anyways (eg, create database on a database that already exists does
     ;; nothing, but is counted as an error).
     ;; Subshell used to isolate any cd
     (str "psql script" (if title (str " - " title) ""))
     ("(\n"
      cd (~lib/user-home ~as-user) "&&"
      sudo "-u" ~as-user
      ~(if (:has-pg-wrapper settings)
         ""
         (format
          "env PGHOST=%s PGDATA=%s PGPORT=%s"
          (-> cluster-settings :options :unix_socket_directory)
          (-> cluster-settings :options :data_directory)
          (-> cluster-settings :options :port)))
      psql
      ~(if (:has-pg-wrapper settings)
         (format "--cluster %s/%s" (:version settings) cluster)
         "")
      ~(if db-name (str "-d " db-name) "")
      "-f" ~file
      ~(if show-stdout "" ">-")
      ~(if ignore-result "2>-" "")
      ~(if ignore-result "|| true" "") "\n )"))
    (remote-file file :action :delete)))

(defn create-database
  "Create a database if it does not exist.

   You can specify database parameters by including a keyed parameter called
   :db-parameters, which indicates a vector of strings or keywords that will get
   translated in order to the options to the create database command. Passes on
   key/value arguments it does not understand to postgresql-script.

   Example: (create-database
              \"my-database\" :db-parameters [:encoding \"'LATIN1'\"])"
  [db-name & {:keys [db-parameters db] :as options}]
  (let [db-parameters-str (string/join " " (map name db-parameters))]
    ;; Postgres simply has no way to check if a database exists and issue a
    ;; "CREATE DATABASE" only in the case that it doesn't. That would require a
    ;; function, but create database can't be done within a transaction, so
    ;; you're screwed. Instead, we just use the fact that trying to create an
    ;; existing database does nothing and stuff the output/error return.
    (apply-map
     postgresql-script
     :content (format "CREATE DATABASE %s %s;" db-name db-parameters-str)
     :literal true
     :ignore-result true
     options)))

;; This is a format string that generates a temporary PL/pgsql function to
;; check if a given role exists, and if not create it. The first argument
;; should be the role name, the second should be any user-parameters.
(defn- create-role-pgsql
  [version]
  (cond
   (re-matches #"9.[0-2]" version)
   "do $$declare user_rec record;
BEGIN
 select into user_rec * from pg_roles where rolname='%1$s';
 if user_rec.rolname is null then
     create role %1$s %2$s;
 else
     alter role %1$s %2$s;
 end if;
END$$;"
   :else
   "create or replace function pg_temp.createuser() returns void as $$
 declare user_rec record;
 begin
 select into user_rec * from pg_roles where rolname='%1$s';
 if user_rec.rolname is null then
     create role %1$s %2$s;
 end if;
 end;
 $$ language plpgsql;
 select pg_temp.createuser();"))

(defn create-role
  "Create a postgres role if it does not exist.

   You can specify user parameters by including a keyed parameter called
   :user-parameters, which indicates a vector of strings or keywords that will
   get translated in order to the options to the create user command. Passes on
   key/value arguments to postgresql-script.

   Example (create-role
             \"myuser\" :user-parameters [:encrypted :password \"'mypasswd'\"])"
  [username & {:keys [user-parameters db instance-id] :as options}]
  (let [settings (get-settings facility options)
        user-parameters-str (string/join " " (map name user-parameters))]
    (apply-map
     postgresql-script
     :content (format
               (create-role-pgsql (:version settings))
               username
               (if (string/blank? user-parameters-str)
                 ""
                 (str "WITH " user-parameters-str)))
     :literal true
     options)))


(defn service
  "Control the postgresql service.

   Specify `:if-config-changed true` to make actions conditional on a change in
   configuration.

   Other options are as for `pallet.action.service/service`. The service
   name is looked up in the request parameters."
  [& {:keys [action if-config-changed if-flag instance-id] :as options}]
  (let [settings (get-settings facility options)
        service-name (:service settings)
        options (if if-config-changed
                  (assoc options :if-flag postgresql-config-changed-flag)
                  options)]
    (if (:has-multicluster-service settings)
      (apply-map actions/service service-name options)
      (doseq [cluster (keys (:clusters settings))]
        (let [cluster-name (name cluster)
              cluster-settings (settings-for-cluster cluster-name options)]
          (if (= :auto (-> cluster-settings :start :start))
            (apply-map
             actions/service (:service cluster-settings) options)))))))

(defn controldata-script
  [{:keys [as-user instance-id cluster] :as options}]
  (let [settings (get-settings facility options)
         cluster (or cluster (:default-cluster-name settings))
         cluster-settings (settings-for-cluster cluster options)
         as-user (or as-user (-> settings :owner))]
     (stevedore/script
      ("sudo" "-u" ~as-user
       ~(if-let [bin (:bin settings)]
          (str bin "/pg_controldata")
          "pg_controldata")
       ~(-> cluster-settings :options :data_directory)))))

(defn controldata
  "Execute pg_controldata."
  [session & {:keys [as-user instance-id cluster] :as options}]
  (exec-checked-script
   "pg_controldata"
   (~controldata-script session options)))

(defn log-settings
  "Log postgresql settings"
  [& {:keys [instance-id level] :or {level :info} :as options}]
  (let [settings (get-settings facility options)]
    (logging/log level
                 (format "Postgresql %s %s" (or instance-id "") settings))))

(defplan configure
  [{:keys [instance-id] :as options}]
  (initdb options)
  (hba-conf options)
  (postgresql-conf options)
  (service-config options)
  (port-config options)
  (dir-config options))


(defn server-spec
  "Return a postgres server-spec using the specified `settings`."
  [settings & {:keys [instance-id] :as options}]
  (api/server-spec
   :phases {:settings (plan-fn
                        (pallet.crate.postgres/settings
                         (settings-map settings)))
            :install (plan-fn
                       (install options))
            :configure (plan-fn
                         (configure options)
                         (service
                          :action :restart :if-config-changed true))}
   :default-phases [:install :configure]))
